

# ğŸ“ Boyerâ€“Moore Majority Vote Algorithm

---

## ğŸ“Œ Problem Context

* **Typical Problem**: Find the **majority element** (appears more than âŒŠn/2âŒ‹ times).
* **LeetCode Example**: [169. Majority Element](https://leetcode.com/problems/majority-element/)
* **Guarantee**: Majority element always exists.

---

## ğŸ¯ Intuition

* Imagine pairing different elements against each other.
* Since the majority element appears **more than half the time**, it **cannot be completely canceled out**.
* After all â€œcancellations,â€ the element left is the majority.

---

## âš¡ Algorithm Steps

Maintain two variables:

1. `candidate` â†’ stores the current guess.
2. `count` â†’ balance counter.

Process each number in the array:

1. If `count == 0`, set `candidate = num`.
2. If `num == candidate`, increment `count`.
3. Else, decrement `count`.

At the end, `candidate` is the majority element.

---

## âœ… Dry Run Example

Input: `nums = [2,2,1,1,1,2,2]`

| Step | num | candidate | count | Action                  |
| ---- | --- | --------- | ----- | ----------------------- |
| 1    | 2   | 2         | 1     | candidate chosen        |
| 2    | 2   | 2         | 2     | same â†’ count++          |
| 3    | 1   | 2         | 1     | diff â†’ count--          |
| 4    | 1   | 2         | 0     | diff â†’ count--          |
| 5    | 1   | 1         | 1     | count=0 â†’ new candidate |
| 6    | 2   | 1         | 0     | diff â†’ count--          |
| 7    | 2   | 2         | 1     | count=0 â†’ new candidate |

Final Answer â†’ `2`

---

## ğŸ–¥ï¸ Code (Python)

```python
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        candidate, count = None, 0
        for num in nums:
            if count == 0:
                candidate = num
            count += 1 if num == candidate else -1
        return candidate
```

---

## â± Complexity

* **Time**: O(n) â†’ single pass.
* **Space**: O(1) â†’ only two variables.

---

## âš ï¸ Limitations

* Works **only if a majority element exists**.
* If not guaranteed, you must run an **extra verification pass** at the end:

```python
if nums.count(candidate) > len(nums)//2:
    return candidate
else:
    return None
```

---

## ğŸ”® Generalization

* For finding elements appearing **> âŒŠn/3âŒ‹** â†’ maintain 2 candidates + counts.
* For **> âŒŠn/kâŒ‹** â†’ maintain `k-1` candidates + counts.

---

## ğŸ§  Key Interview Notes

* Sorting solution: `nums[n//2]` also works but is O(n log n).
* Hash map solution: O(n) time, O(n) space.
* Boyerâ€“Moore is **optimal**: O(n) time, O(1) space.
* Think of it as â€œcanceling out votes.â€

---

âœ… This covers **intuition, dry run, code, complexity, limitations, generalization, and interview notes**.

